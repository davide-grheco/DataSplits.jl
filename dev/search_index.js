var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#DataSplits.KennardStoneSplit","page":"Reference","title":"DataSplits.KennardStoneSplit","text":"KennardStoneSplit{T} <: SplitStrategy\n\nA splitting strategy implementing the Kennard-Stone algorithm for train/test splitting.\n\nFields\n\nfrac::ValidFraction{T}: Fraction of data to use for training (0 < frac < 1)\nmetric::Distances.SemiMetric: Distance metric to use (default: Euclidean())\n\nExamples\n\n```julia\n\nCreate a splitter with 80% training data using Euclidean distance\n\nsplitter = KennardStoneSplit(0.8)\n\nCreate a splitter with custom metric\n\nusing Distances splitter = KennardStoneSplit(0.7, Cityblock())\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#DataSplits.SPXYSplit-Tuple{Real}","page":"Reference","title":"DataSplits.SPXYSplit","text":"SPXYSplit(frac; metric = Euclidean())\n\nCreate an SPXY splitter – the variant of Kennard–Stone in which the distance matrix is the element‑wise sum of\n\nthe (normalised) pairwise distance matrix of the feature matrix X\nplus the (normalised) pairwise distance matrix of the response vector y.\n\nfrac is the fraction of samples that will end up in the training subset.\n\nnote: Note\nsplit must be called with a 2‑tuple (X, y) or with positional arguments split(X, y, strategy); calling split(X, strategy) will raise a MethodError, because y is mandatory for SPXY.\n\nArguments\n\nname type meaning\nfrac Real (0 < frac < 1) training‑set fraction\nmetric [Distances.SemiMetric] distance metric used for both X and y\n\nSee also\n\nKennardStoneSplit — the classical variant that uses only X.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits._get_sample-Tuple{AbstractArray, Any}","page":"Reference","title":"DataSplits._get_sample","text":"_get_sample(A::AbstractArray, i)\n\nGet the i-th sample from an array along the first dimension, returning a view when possible. For matrices this returns a row, for 3D arrays a matrix slice, etc.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits._sort_indices!-Tuple{AbstractRange, Any}","page":"Reference","title":"DataSplits._sort_indices!","text":"_sort_indices(range, indices) -> Vector{eltype(range)}\n\nReturns sorted indices while preserving the original index type (Int, Offset, etc.). Memory-efficient for contiguous ranges.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits._split-Tuple{AbstractArray, AbstractVector, SPXYSplit}","page":"Reference","title":"DataSplits._split","text":"_split(X, y, strategy::SPXYSplit; rng = Random.GLOBAL_RNG) → (train_idx, test_idx)\n\nSplit a feature matrix X and response vector y into train/test subsets using the SPXY algorithm:\n\nBuild the joint distance matrix D = D_X + D_Y  (see SPXYSplit for details).\nRun the Kennard–Stone maximin procedure on D.\nReturn two sorted index vectors (train_idx, test_idx).\n\nArguments\n\nname type requirement\nX AbstractMatrix size(X, 1) == length(y)\ny AbstractVector \nstrategy SPXYSplit created with SPXYSplit(frac; metric)\nrng random‑number source unused here but kept for API symmetry\n\nReturns\n\nTwo Vector{Int} with the row indices of X (and the corresponding entries of y) that belong to the training and test subsets.\n\nThe indices are axis‑correct — if X is an OffsetMatrix whose first row is index 0, the returned indices will also start at 0.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits._split-Tuple{Any, KennardStoneSplit}","page":"Reference","title":"DataSplits._split","text":"_split(data, s::KennardStoneSplit; rng=Random.GLOBAL_RNG) → (train_idx, test_idx)\n\nOptimized in-memory Kennard-Stone algorithm using precomputed distance matrix. Best for small-to-medium datasets where O(N²) memory is acceptable.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits._split-Tuple{Any, LazyKennardStoneSplit}","page":"Reference","title":"DataSplits._split","text":"_split(data, s::KennardStoneSplit; rng=Random.GLOBAL_RNG) → (train_idx, test_idx)\n\nKennard-Stone (CADEX) algorithm for optimal train/test splitting using maximin strategy. Memory-optimized implementation with O(N) storage. Useful when working with large datasets where the NxN distance matrix does not fit memory. When working with small datasets, use the traditional implementation.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits.find_most_distant_pair-Tuple{AbstractMatrix}","page":"Reference","title":"DataSplits.find_most_distant_pair","text":"find_most_distant_pair(D::AbstractMatrix) → (i, j)\n\nFinds indices of most distant pair in precomputed distance matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#DataSplits.split-Tuple{Any, SplitStrategy}","page":"Reference","title":"DataSplits.split","text":"split(data, strategy; rng=Random.default_rng()) → (train, test)\n\nSplit data into train/test sets according to strategy.\n\n\n\n\n\n","category":"method"},{"location":"#DataSplits","page":"DataSplits","title":"DataSplits","text":"","category":"section"},{"location":"","page":"DataSplits","title":"DataSplits","text":"Documentation for DataSplits.","category":"page"},{"location":"","page":"DataSplits","title":"DataSplits","text":"A tiny Julia library for rational train/test splitting algorithms:","category":"page"},{"location":"","page":"DataSplits","title":"DataSplits","text":"Strategy Purpose Complexity\nKennardStoneSplit Maximin split on X O(N²) time, O(N²) memory\nLazyKennardStoneSplit Same, streamed O(N²) time, O(N) mem\nSPXYSplit Joint X–y maximin (SPXY) O(N²) time, O(N²) mem","category":"page"},{"location":"","page":"DataSplits","title":"DataSplits","text":"julia> using DataSplits, Distances\n\njulia> train, test = split(X, KennardStoneSplit(0.8))\njulia> train, test = split((X, y), SPXYSplit(0.7; metric = Cityblock()))","category":"page"}]
}
